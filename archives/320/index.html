<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,ç†ŠçŒ«å°A,Galileo,blog" />
    <meta name="generator" content="Maverick 1.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’ &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’ &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/993aa3dcb70943b3e506b13b3d502541.json"
        }

    </script>
    
<title>Let's talk about Clustering - æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’</title>
<meta name="author" content="ç†ŠçŒ«å°A" />
<meta name="description" content="A brief introduction on traditional clustering algorithms, and a novel new method â€”â€” Clustering by fast search and find of density peaks." />
<meta property="og:title" content="Let's talk about Clustering - æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’" />
<meta property="og:description" content="A brief introduction on traditional clustering algorithms, and a novel new method â€”â€” Clustering by fast search and find of density peaks." />
<meta property="og:site_name" content="æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/archives/320/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2019-04-25T23:54:00-00.00" />
<meta name="twitter:title" content="Let's talk about Clustering - æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’" />
<meta name="twitter:description" content="A brief introduction on traditional clustering algorithms, and a novel new method â€”â€” Clustering by fast search and find of density peaks." />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
<link rel="dns-prefetch" href="//blog.imalan.cn" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/brand_font/embed.css" />
<style>.brand{font-family:FZCuJinLFW,serif;font-weight: normal!important;}</style>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/apple-touch-icon.png?v=PY43YeeEKx">
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/favicon-32x32.png?v=yyLyaqbyRG">
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/favicon-16x16.png?v=yyLyaqbyRG">
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/safari-pinned-tab.svg?v=yyLyaqbyRG" color="#505050">
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/favicon.ico?v=yyLyaqbyRG">
<meta name="application-name" content="ä¸‰ç„¡è¨ˆåŠƒ">
<meta name="apple-mobile-web-app-title" content="ä¸‰ç„¡è¨ˆåŠƒ">
<meta name="msapplication-TileColor" content="#000000">
<meta name="theme-color" content="#000000">
<meta name="baidu-site-verification" content="9BEwwo6Ibg" />

</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’</a></h1>
            <p>åªåšæŒä¸€ç§æ­£ä¹‰ã€‚æˆ‘çš„æ­£ä¹‰ã€‚</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase " href="/" target="_self">é¦–é¡µ</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">å½’æ¡£</a></li><li><a class="no-link text-uppercase " href="/links/" target="_self">å‹é“¾</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">å…³äº</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">æœç´¢</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>
    <section class="prism-section row" id="prism__content">
        <article class="yue col-md-8 offset-md-2">
            <h1 class="prism-post-title">Let's talk about Clustering</h1>
            <div class="prism-post-time">
                <time class="text-uppercase">
                    April 25 2019
                </time>
            </div>
            <div class="prism-content-body">
                <p>This post is about clustering. I will make a short introduction of traditional methods, then talk about a magical algorithm published by Alex Rodriguez and Alessandro Laio on <a href="https://science.sciencemag.org/content/344/6191/1492.full">Science magazine</a>, 2014. I call it magical because it's simple yet powerful, and super intuitive. The principle behind it is really semantic.</p>
<p>Clustering, as a kind of unsupervised learning method, aims to divide dataset into some pieces (i.e. "classes"), making the <strong>intraclass difference</strong><sup id="fn_ref_1"><a href="#fn_1">1</a></sup> as small as possible while the <strong>interclass difference</strong><sup id="fn_ref_2"><a href="#fn_2">2</a></sup> as large as possible.</p>
<p>For example, the picture bellow shows 5000 points scattered on a 2-D plane, we humans can easily assign them into 15 groups, because there is an obvious distributing pattern of these points. The question is, how could computers finish this job?</p>
<p><figure class="pswp-item" style="flex: 50.0" data-width="100" data-height="100"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/54ba94e700b9b152723d423398fcef4d.png" alt="5000 points scattered on a 2-D plane" /><figcaption>5000 points scattered on a 2-D plane</figcaption></figure></p>
<h2>Traditional methods</h2>
<p>In the past few decades many algorithms have been developed just to finish this "simple" task, some of them are quite delicate and beautiful. However, depending on the rationale behind them, they all have some shortcomings like any other algorithm does. They are either slow or too complicated to implement, or just cannot finish the job.</p>
<p>The <strong>C-Means</strong> algorithm might be the most famous one of its kind. We randomly choose some points as cluster centers at first, then we assign points into some clusters by their "distance" to cluster centers, then calculate new centers to replace old ones. This procedure is accomplished by repeating those steps several times, until cluster centers do not move anymore. This method is inspirational, and many similar methods have been developed, such as <strong>Fuzzy C-Means</strong>, which uses a fuzzy matrix to weight the target function. This kind of algorithms are easy to implement and are simple to understand, but as been mentioned above, the initial cluster centers are very important, and results vary under different initial state. That makes these algorithms not robust enough, thus not reliable in some cases.</p>
<p>Another kind of algorithms are build upon statistics, such as <strong>Guassian Mixed Model (GMM)</strong> algorithm. It assumes that data points are just samples from some mixed Guassian models, therefore the clustering task is equal to estimate several Guassian models, to make the posterior probability as large as possible. Theoretical foundation of these algorithms are clear, mathematics makes them look reliable. However, initial state still affects the result, and most importantly, the basic assumption â€” "data points are just samples from some mixed Guassian models" â€” isn't always true. Another problem is, this algorithm could be very slow with large datasets.</p>
<p>Some other algorithms exist, like <strong>Hierarchical Clustering</strong>, which works fine under discrete feature values. It regards each points as a single cluster at first, then combines two clusters each time, repeat this step until the total number of clusters reduces to a certain level. It sounds simple, but again, it's slow with large datasets, and not robust enough.</p>
<h2>A new method</h2>
<p>Algorithms mentioned above are highlights of clustering methods. Most of them are iterative methods, and could be time consuming with large datasets. People have found an acceptable principle: a good clustering method is an algorithm which can fully summarize the common features of points, while making different clusters faraway from each other.</p>
<p>A new method was introduced by Alex Rodriguez and Alessandro Laio in 2014, their paper was published on Science. This already indicates that their algorithm must have something special, since papers in this field are hardly seen on magazines like Science. It is worth mentioning that deep learning researches were already super popular in 2014, which makes this algorithm even more admirable â€” it has absolutely nothing to do with deep learning.</p>
<p>This algorithm is based on two principles, <strong>only two</strong>:</p>
<ol>
<li><strong>Cluster centers are points with high "Local Density ($\rho$)"</strong></li>
<li><strong>Cluster centers are points with high "Relative Distance ($\delta$)"</strong></li>
</ol>
<h3>Local Density</h3>
<p>How to understand these two principles? Well, the first is relatively easy: cluster centers tends to have more points around them, than other regular none-center points. Imagine a leader of a team, or the head of a gang, they are always surrounded by many other "little guys".</p>
<p>For each point, we simply count the number of points around it, that is, closer than a predefined cut-distance â€” $d_c$:</p>
<p>$$\rho_i = \sum \chi(d_{ij} - d_c)$$</p>
<p>And we have :</p>
<p>$$\chi(x) = 1|_{x<0}, \chi(x)=0|_{x\ge 0}$$</p>
<p>Geometrically, this step equals to drawing a circle (or spherical surface with higher dimensions) using $d_c$ as radius and $point_i$ as center, then count the number of points inside the circle.</p>
<h3>Relative Distance</h3>
<p>This is a little more difficult to understand. Actually "Relative distance" means "<strong>minimum distance to points with higher local density</strong>", that is for each point $P_i$ with local density $\rho_i$, we calculate distances between $P_i$ and any other point $P_j$ with local density $\rho_j > \rho_i$, then use the minimal distance as the "Relative Distance" of $P_i$. But WHY?</p>
<p>We can easily understand why we choose points with high Local Density ($\rho$) as cluster center candidates â€” because points around them are compact. But don't forget, another criteria is also important for cluster centers: <strong>distance between clusters should be as large as possible</strong>. It is reasonable, think about it: if cluster centers are too close to each other, there must be huge overlap between clusters, that usually isn't ideal result.</p>
<p>Again, imagine a man who want to be a leader of a team, firstly he gathered a lot "little guys", then he must want to keep distance to those "bigger bosses", otherwise he might lose in competition. The Relative Distance ($\delta$) is used to measure the distance between $P_i$ and any other cluster center candidates, as explained, this value should be as large as possible. Therefore, $\delta_i$ for $P_i$ could be calculated as:</p>
<p>$$\delta_i = \min(d_{ij}) |_{\rho_j>\rho_i}$$</p>
<p>If $P_i$ already has the biggest $\rho$, just let:</p>
<p>$$\delta_i = \max(\rho_j) |_{j\ne i}$$</p>
<p>And $d_{ij}$ means Euclidean distance between $P_i$ and $P_j$.</p>
<h3>Implementation</h3>
<p>I implemented this algorithm using Matlab, guess how many lines of code does it need?</p>
<div class="highlight"><pre><span></span><span class="k">function</span><span class="w"> </span>[centers_o, Rho_o, Delta_o] <span class="p">=</span><span class="w"> </span><span class="nf">fsfdp</span><span class="p">(</span>dataset_i, NumCategory_i, dc_i<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">%%%%%</span>
    <span class="c">% Clustering by Fast search and find of density peaks</span>
    <span class="c">% AlanDecode</span>
    <span class="c">% </span>
    <span class="c">% dataset_i: N * D</span>
    <span class="c">% NumCategory_i: number of categories</span>
    <span class="c">% dc_i: cut distance</span>

    <span class="c">%% Dataset</span>
    <span class="n">dataset</span> <span class="p">=</span> <span class="n">dataset_i</span><span class="p">;</span>
    <span class="n">datasetSize</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">dataset</span><span class="p">);</span>
    <span class="n">NumCategory</span> <span class="p">=</span> <span class="n">NumCategory_i</span><span class="p">;</span>

    <span class="c">%% Algorithm</span>

    <span class="c">% Calc distance between points</span>
    <span class="n">distMat</span> <span class="p">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">dataset</span><span class="p">);</span>
    <span class="n">distMat</span> <span class="p">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">distMat</span><span class="p">);</span>

    <span class="c">% Calc Rho (local density)</span>
    <span class="n">Rho</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">datasetSize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span><span class="n"></span>
<span class="n">    for </span><span class="s">idx = 1:datasetSize(1)</span><span class="p"></span>
        <span class="n">dists</span> <span class="p">=</span> <span class="n">distMat</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">:);</span>
        <span class="n">Rho</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">=</span> <span class="nb">size</span><span class="p">(</span><span class="n">dists</span><span class="p">(</span><span class="n">dists</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;</span> <span class="n">dists</span> <span class="o">&lt;</span> <span class="n">dc_i</span><span class="p">),</span> <span class="mi">2</span><span class="p">);</span><span class="n"></span>
<span class="n">    end</span>

<span class="n">    </span><span class="s">% Sort</span><span class="p"></span>
    <span class="p">[</span><span class="o">~</span><span class="p">,</span> <span class="n">rhoIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">Rho</span><span class="p">,</span> <span class="s">&#39;descend&#39;</span><span class="p">);</span>

    <span class="c">% Calc Delta (minimum distance between one point </span>
    <span class="c">% and any other point with higher density)</span>
    <span class="n">Delta</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">datasetSize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span><span class="n"></span>
<span class="n">    for </span><span class="s">idx = 1:datasetSize(1)</span><span class="p"></span>
<span class="n">        if </span><span class="s">idx == 1</span><span class="p"></span>
            <span class="c">% point with highest rho</span>
            <span class="n">index</span> <span class="p">=</span> <span class="n">rhoIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="c">% use highest distance as Delta</span>
            <span class="n">dists</span> <span class="p">=</span> <span class="n">distMat</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">:);</span>
            <span class="n">Delta</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dists</span><span class="p">);</span><span class="n"></span>
<span class="n">        else</span>
<span class="n">            </span><span class="s">% current point</span><span class="p"></span>
            <span class="n">index</span> <span class="p">=</span> <span class="n">rhoIndex</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>

            <span class="c">% points with higher rho</span>
            <span class="n">rhoIndexSlice</span> <span class="p">=</span> <span class="n">rhoIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">p1</span> <span class="p">=</span> <span class="n">dataset</span><span class="p">(</span><span class="n">rhoIndexSlice</span><span class="p">,</span> <span class="p">:);</span>

            <span class="c">% calc distance</span>
            <span class="n">p2</span> <span class="p">=</span> <span class="nb">repmat</span><span class="p">(</span><span class="n">dataset</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">:),</span> <span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">dists</span> <span class="p">=</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">sum</span><span class="p">((</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span><span class="o">.^</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

            <span class="c">% minimal distance</span>
            <span class="n">Delta</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="p">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dists</span><span class="p">);</span><span class="n"></span>
<span class="n">        end</span>
<span class="n">    </span><span class="s">end</span><span class="p"></span>

    <span class="c">% Find centers, composite Rho and Delta</span>
    <span class="n">Temp</span> <span class="p">=</span> <span class="n">Rho</span><span class="o">.^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Delta</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
    <span class="p">[</span><span class="o">~</span><span class="p">,</span> <span class="n">tempIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">Temp</span><span class="p">,</span> <span class="s">&#39;descend&#39;</span><span class="p">);</span>
    <span class="c">% highest [NumCategory] values</span>
    <span class="n">tempIndexSlice</span> <span class="p">=</span> <span class="n">tempIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">NumCategory</span><span class="p">);</span>
    <span class="n">centers</span> <span class="p">=</span> <span class="n">dataset</span><span class="p">(</span><span class="n">tempIndexSlice</span><span class="p">,</span> <span class="p">:);</span>

    <span class="c">% Return</span>
    <span class="n">Rho_o</span> <span class="p">=</span> <span class="n">Rho</span><span class="p">;</span>
    <span class="n">Delta_o</span> <span class="p">=</span> <span class="n">Delta</span><span class="p">;</span>
    <span class="n">centers_o</span> <span class="p">=</span> <span class="n">centers</span><span class="p">;</span><span class="n"></span>
<span class="n">end</span>
</pre></div>
<p>You can see the core part contains less than 50 lines of code, it is so concise that I even doubted myself. But the result reassured meï¼š</p>
<p><figure class="pswp-item" style="flex: 117.54756871035941" data-width="1112" data-height="473"><img src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/archives/assets/91e42a37259c862eff50b74848c93363.jpg" alt="Result of FSFDP algorithm" /><figcaption>Result of FSFDP algorithm</figcaption></figure></p>
<p>Cluster centers are drawn using blue circles on the right-hand figure. And we can clearly see 15 points with high $\rho$ and $\delta$ one the left-hand figure. This algorithm is not iterative, the most time consuming step is sorting. This is inevitable though, because the sorting result is necessary for calculating $\delta$.</p>
<hr>
<p>Dataset in this post could be downloaded <a href="/resources/s1.txt">here</a>, just load it in Matlab. It includes coordinates of 5000 2-D points.</p>
<hr><div class="footnotes"><ol><li id="fn_1">the differences of data points in the same class <a no-style href="#fn_ref_1">â†©</a></li><li id="fn_2">the differences of data points in different classes <a no-style href="#fn_ref_2">â†©</a></li></ol></div>
            </div>
        </article>
        <div class="prism-post-meta col-md-8 offset-md-2">
    <span>ç†ŠçŒ«å°A</span>
    
    <span>/</span>
    <span>
        <a class="category no-link" href="/category/å¶å°”Geek/" target="_self">
        å¶å°”Geek
        </a>
    </span>
    
    
    <span>/</span>
    
    <span class="prism-tag">
        <a class="no-link" href="/tag/ç®—æ³•/" target="_self">#ç®—æ³•</a>
    </span>
    
    <span class="prism-tag">
        <a class="no-link" href="/tag/æœºå™¨å­¦ä¹ /" target="_self">#æœºå™¨å­¦ä¹ </a>
    </span>
    
    
    
    <span>/</span>
    <span class="leancloud_visitors" id="/archives/320/" data-flag-title="Let's talk about Clustering"><span class="leancloud-visitors-count"></span> Views</span>
    
</div>
    </section>

    
<section id="prism__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
    <ul>
        
        <li class="next">
            <a class="no-link" href="/archives/321/" target="_self" title="ç‹‚äººæ—¥è®°"><i class="fa fa-chevron-left" aria-hidden="true"></i>æ›´æ–°</a>
        </li>
        
        
        <li class="prev">
            <a class="no-link" href="/archives/317/" target="_self" title="æ˜¥å¤©ã€è”è°Šã€æ–°è€³æœº">æ›´æ—§<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
        </li>
        
    </ul>
</section>


    
    <script>
        var initValine = function() {
            new Valine({"enable": true, "el": "#vcomments", "appId": "6chFXPTjrjYnjFk9duROcboN-gzGzoHsz", "appKey": "c1CRooaFmpLs4xi7x3YLm3ma", "visitor": true, "recordIP": true, "placeholder": "\u6765\u7545\u6240\u6b32\u8a00\u5427~"});
        }

    </script>
    <script defer src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js' onload="initValine()"></script>
    <div class="prism-comment-section container" id="prism__comment">
        <div class="row">
            <div class="col-md-8 offset-md-2">
                <div id="vcomments"></div>
            </div>
        </div>
    </div>
    

</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/AlanDecode" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/AlanDecode" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/5245109677/" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>ï¼šğŸ„â€ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">ä¸‰ç„¡è¨ˆåŠƒ</a>ï¼šä¸‰æ˜¯è™šæŒ‡ã€‚è‡³äºæ˜¯å“ªä¸‰æ— ï¼Œæˆ‘å””çŸ¥ã€‚
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://wiki.imalan.cn" rel="noopener noreferrer nofollow">ç„¡çŸ¥è­˜</a>ï¼šç†ŠçŒ«å°Açš„Wikiç«™ç‚¹ã€‚éš¶å±äºã€Œä¸‰æ— è®¡åˆ’ã€ã€‚
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://lab.imalan.cn" rel="noopener noreferrer nofollow">ç„¡é …ç›®</a>ï¼šç†ŠçŒ«å°Açš„å®éªŒå®¤ã€‚éš¶å±äºã€Œä¸‰æ— è®¡åˆ’ã€ã€‚
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://t.me/triple_null" rel="noopener noreferrer nofollow">ç„¡æ¶ˆæ¯</a>ï¼šç†ŠçŒ«å°Açš„å¹¿æ’­ã€‚éš¶å±äºã€Œä¸‰æ— è®¡åˆ’ã€ã€‚
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">æ— æ–‡å­— | ä¸‰æ— è®¡åˆ’</span>
                            <span>Copyright Â© 2020 ç†ŠçŒ«å°A</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
<a no-style href="http://beian.miit.gov.cn" target="_blank">äº¬ICPå¤‡18000133å·-1</a> | 
<a no-style href="https://www.upyun.com" target="_blank">åˆæ‹äº‘</a>

                    </div>
                </section>
                <script>
                    var site_build_date = "2017-06-29T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/prism-a1bd79b1a4.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/AlanDecode/site-Blog@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
<script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e4f3a7c02ac2aabc41a1cfa95f61a026";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
</script>
<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
<script>
if(window.location.hash){
    var checkExist = setInterval(function() {
       if ($(window.location.hash).length) {
          $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
          clearInterval(checkExist);
       }
    }, 100);
}
</script>
<script>
if(window.navigator && navigator.serviceWorker) {
  caches.keys().then(function(cacheNames) {
    cacheNames.forEach(function(cacheName) {
      caches.delete(cacheName);
    });
  }).then(function(){
    console.log('Cache cleaned.');
  });
  navigator.serviceWorker.getRegistrations()
  .then(function(registrations) {
    for(let registration of registrations) {
      registration.unregister();
    }
  }).then(function(){
    console.log('Service Worker stopped.');
  });
}
</script>

</body>

</html>